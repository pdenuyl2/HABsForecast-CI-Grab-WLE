geom_smooth(method="lm", formula=y~log(x), se=FALSE) +
stat_cor(label.x = 2200000, label.y = 20) +
labs(y = "CI", x = "16S-Total qPCR gc/mL", title = "2018/2019 - CI - Closest Measurement") +
geom_hline(data = MODIS_combined, aes(yintercept = 0)) +
scale_y_continuous(
limits=c(-10, 260),
breaks=c(0, 50, 100, 150, 200, 250))
plotComb_1km <- ggplot(MODIS_combined,
aes(x=total_cyanobacteria_qpcr_gc_per_ml, y=mean_nD)) +
geom_point() +
geom_smooth(method="lm", formula=y~log(x), se=FALSE) +
stat_cor(label.x = 2200000, label.y = 20) +
labs(y = "CI", x = "16S-Total qPCR gc/mL", title = "2018/2019 - Mean CI - 1km Radius") +
geom_hline(data = MODIS_combined, aes(yintercept = 0)) +
scale_y_continuous(
limits=c(-10, 260),
breaks=c(0, 50, 100, 150, 200, 250))
plotComb_5km <- ggplot(MODIS_combined,
aes(x=total_cyanobacteria_qpcr_gc_per_ml, y=mean_nDD)) +
geom_point() +
geom_smooth(method="lm", formula=y~log(x), se=FALSE) +
stat_cor(label.x = 2200000, label.y = 20) +
labs(y = "CI", x = "16S-Total qPCR gc/mL", title = "2018/2019 - Mean CI - 5km Radius") +
geom_hline(data = MODIS_combined, aes(yintercept = 0)) +
scale_y_continuous(
limits=c(-10, 260),
breaks=c(0, 50, 100, 150, 200, 250))
rm(list=ls());if(is.null(dev.list()["RStudioGD"])){} else {dev.off(dev.list()["RStudioGD"])};cat("\014")
setwd('/Users/pdenuyl/Documents/3GESP/metadata/3GESP/For-MODIS/')
MODIS_2018 <- read.csv("MODIS_only_erie_metadata_2018_v8_PD.csv")
MODIS_2018 <- na.omit(MODIS_2018)
MODIS_2019 <- read.csv("MODIS_only_erie_metadata_2019_v3_PD.csv")
MODIS_combined <- read.csv("combined_MODIS_erie_metadata_2018_2019_PD.csv")
library(tidyverse)
library(ggplot2)
library(ggpubr)
##########
###2018###
###########
plot2018_close <- ggplot(MODIS_2018,
aes(x=total_cyanobacteria_qpcr_gc_per_ml, y=modis_exact_ci)) +
geom_point() +
geom_smooth(method="lm", formula=y~log(x), se=FALSE) +
stat_cor(label.x = 2200000, label.y = 20) +
labs(y = "CI", x = "16S-Total qPCR gc/mL", title = "2018 - CI - Closest Measurement") +
geom_hline(data = MODIS_combined, aes(yintercept = 0)) +
scale_y_continuous(
limits=c(-10, 260),
breaks=c(0, 50, 100, 150, 200, 250)) +
scale_x_continuous(
limits=c(0, 3500000),
breaks=c(0, 1000000, 2000000, 3000000))
plot2018_1km <- ggplot(MODIS_2018,
aes(x=total_cyanobacteria_qpcr_gc_per_ml, y=mean_nD)) +
geom_point() +
geom_smooth(method="lm", formula=y~log(x), se=FALSE) +
stat_cor(label.x = 2200000, label.y = 20) +
labs(y = "CI", x = "16S-Total qPCR gc/mL", title = "2018 - Mean CI - 1km Radius") +
geom_hline(data = MODIS_combined, aes(yintercept = 0)) +
scale_y_continuous(
limits=c(-10, 260),
breaks=c(0, 50, 100, 150, 200, 250)) +
scale_x_continuous(
limits=c(0, 3500000),
breaks=c(0, 1000000, 2000000, 3000000))
plot2018_5km <- ggplot(MODIS_2018,
aes(x=total_cyanobacteria_qpcr_gc_per_ml, y=mean_nDD)) +
geom_point() +
geom_smooth(method="lm", formula=y~log(x), se=FALSE) +
stat_cor(label.x = 2200000, label.y = 20) +
labs(y = "CI", x = "16S-Total qPCR gc/mL", title = "2018 - Mean CI - 5km Radius") +
geom_hline(data = MODIS_combined, aes(yintercept = 0)) +
scale_y_continuous(
limits=c(-10, 260),
breaks=c(0, 50, 100, 150, 200, 250)) +
scale_x_continuous(
limits=c(0, 3500000),
breaks=c(0, 1000000, 2000000, 3000000))
fig_all_2018 <- ggarrange(plot2018_close, plot2018_1km, plot2018_5km,
# labels = c("A", "B", "C", "D",
ncol = 3, nrow = 1,
common.legend = FALSE)
fig_all_2018
##########
###2019###
##########
plot2019_close <- ggplot(MODIS_2019,
aes(x=total_cyanobacteria_qpcr_gc_per_ml, y=modis_exact_ci)) +
geom_point() +
geom_smooth(method="lm", formula=y~log(x), se=FALSE) +
stat_cor(label.x = 2200000, label.y = 20) +
labs(y = "CI", x = "16S-Total qPCR gc/mL", title = "2019 - CI - Closest Measurement") +
geom_hline(data = MODIS_combined, aes(yintercept = 0)) +
scale_y_continuous(
limits=c(-10, 260),
breaks=c(0, 50, 100, 150, 200, 250)) +
scale_x_continuous(
limits=c(0, 3500000),
breaks=c(0, 1000000, 2000000, 3000000))
plot2019_1km <- ggplot(MODIS_2019,
aes(x=total_cyanobacteria_qpcr_gc_per_ml, y=mean_nD)) +
geom_point() +
geom_smooth(method="lm", formula=y~log(x), se=FALSE) +
stat_cor(label.x = 2200000, label.y = 20) +
labs(y = "CI", x = "16S-Total qPCR gc/mL", title = "2019 - Mean CI - 1km Radius") +
geom_hline(data = MODIS_combined, aes(yintercept = 0)) +
scale_y_continuous(
limits=c(-10, 260),
breaks=c(0, 50, 100, 150, 200, 250)) +
scale_x_continuous(
limits=c(0, 3500000),
breaks=c(0, 1000000, 2000000, 3000000))
plot2019_5km <- ggplot(MODIS_2019,
aes(x=total_cyanobacteria_qpcr_gc_per_ml, y=mean_nDD)) +
geom_point() +
geom_smooth(method="lm", formula=y~log(x), se=FALSE) +
stat_cor(label.x = 2200000, label.y = 20) +
labs(y = "CI", x = "16S-Total qPCR gc/mL", title = "2019 - Mean CI - 5km Radius") +
geom_hline(data = MODIS_combined, aes(yintercept = 0)) +
scale_y_continuous(
limits=c(-10, 260),
breaks=c(0, 50, 100, 150, 200, 250)) +
scale_x_continuous(
limits=c(0, 3500000),
breaks=c(0, 1000000, 2000000, 3000000))
fig_all_2019 <- ggarrange(plot2019_close, plot2019_1km, plot2019_5km,
# labels = c("A", "B", "C", "D",
ncol = 3, nrow = 1,
common.legend = FALSE)
fig_all_2019
##########
###2018/2019###
###combined###
##########
plotComb_close <- ggplot(MODIS_combined,
aes(x=total_cyanobacteria_qpcr_gc_per_ml, y=modis_exact_ci)) +
geom_point() +
geom_smooth(method="lm", formula=y~log(x), se=FALSE) +
stat_cor(label.x = 2200000, label.y = 20) +
labs(y = "CI", x = "16S-Total qPCR gc/mL", title = "2018/2019 - CI - Closest Measurement") +
geom_hline(data = MODIS_combined, aes(yintercept = 0)) +
scale_y_continuous(
limits=c(-10, 260),
breaks=c(0, 50, 100, 150, 200, 250))
plotComb_1km <- ggplot(MODIS_combined,
aes(x=total_cyanobacteria_qpcr_gc_per_ml, y=mean_nD)) +
geom_point() +
geom_smooth(method="lm", formula=y~log(x), se=FALSE) +
stat_cor(label.x = 2200000, label.y = 20) +
labs(y = "CI", x = "16S-Total qPCR gc/mL", title = "2018/2019 - Mean CI - 1km Radius") +
geom_hline(data = MODIS_combined, aes(yintercept = 0)) +
scale_y_continuous(
limits=c(-10, 260),
breaks=c(0, 50, 100, 150, 200, 250))
plotComb_5km <- ggplot(MODIS_combined,
aes(x=total_cyanobacteria_qpcr_gc_per_ml, y=mean_nDD)) +
geom_point() +
geom_smooth(method="lm", formula=y~log(x), se=FALSE) +
stat_cor(label.x = 2200000, label.y = 20) +
labs(y = "CI", x = "16S-Total qPCR gc/mL", title = "2018/2019 - Mean CI - 5km Radius") +
geom_hline(data = MODIS_combined, aes(yintercept = 0)) +
scale_y_continuous(
limits=c(-10, 260),
breaks=c(0, 50, 100, 150, 200, 250))
fig_all_Comb <- ggarrange(plotComb_close, plotComb_1km, plotComb_5km,
# labels = c("A", "B", "C", "D",
ncol = 3, nrow = 1,
common.legend = FALSE)
fig_all_Comb
#########
#########
#########
fig_all_2018
fig_all_close <- ggarrange(plot2018_close, plot2019_close, plotComb_close,
# labels = c("A", "B", "C", "D",
ncol = 3, nrow = 1,
common.legend = FALSE)
fig_all_close
fig_all_close <- ggarrange(plot2018_close, plot2019_close, plotComb_close,
# labels = c("A", "B", "C", "D",
ncol = 3, nrow = 1,
common.legend = FALSE)
fig_all_1km <- ggarrange(plot2018_1km, plot2019_1km, plotComb_1km,
# labels = c("A", "B", "C", "D",
ncol = 3, nrow = 1,
common.legend = FALSE)
fig_all_5km <- ggarrange(plot2018_5km, plot2019_5km, plotComb_5km,
# labels = c("A", "B", "C", "D",
ncol = 3, nrow = 1,
common.legend = FALSE)
fig_all_1km
fig_all_5km
fig_all_close
fig_all_1km <- ggarrange(plot2018_1km, plot2019_1km, plotComb_1km,
# labels = c("A", "B", "C", "D",
ncol = 3, nrow = 1,
common.legend = FALSE)
fig_all_5km
fig_all_1km
#Assign cartridges/samples of interest
samples <- list("SC53", "SC51", "SC50")
#Set metadata file location
metadata <- data.frame(read_excel("/Users/pdenuyl/Documents/3GESP/metadata/3GESP/For-MODIS/MODIS_only_erie_metadata_2018_v8_PD.xlsx"))
#Set working directory; for hab_tracker code
setwd("~/Documents/R/extract_CI/hab_tracker_2017_code_share/hab_tracker/")
#Assign cartridges/samples of interest
samples <- list("SC53", "SC51", "SC50", "SC48")
#Set metadata file location
metadata <- data.frame(read_excel("/Users/pdenuyl/Documents/3GESP/metadata/3GESP/For-MODIS/MODIS_only_erie_metadata_2018_v8_PD.xlsx"))
#Set working directory; for hab_tracker code
setwd("~/Documents/R/extract_CI/hab_tracker_2017_code_share/hab_tracker/")
#Location of CI processed image (one image/date only)
tiff_ci_location <- "CI Processed/2018/3G-ESP/Aug24_sentinel/Aug24.sentinel-3a.2018236.0824.1546C.L3.LE3.v930044d4967_1_1.CI_PIsrCorr-E-B.tiff"
rm(list=ls());if(is.null(dev.list()["RStudioGD"])){} else {dev.off(dev.list()["RStudioGD"])};cat("\014")
#load packages
library(geosphere)
library(data.table)
library(dplyr)
library(readxl)
library(stringr)
#####################
###Define features###
###This is the only section that needs inputs###
#Limits to eventually put in automation
#Distance
#Number of points to average
#Time
#Assign cartridges/samples of interest
samples <- list("SC53", "SC51", "SC50", "SC48")
#Set metadata file location
metadata <- data.frame(read_excel("/Users/pdenuyl/Documents/3GESP/metadata/3GESP/For-MODIS/MODIS_only_erie_metadata_2018_v8_PD.xlsx"))
#Set working directory; for hab_tracker code
setwd("~/Documents/R/extract_CI/hab_tracker_2017_code_share/hab_tracker/")
#Location of CI processed image (one image/date only)
tiff_ci_location <- "CI Processed/2018/3G-ESP/Aug24_sentinel/Aug24.sentinel-3a.2018236.0824.1546C.L3.LE3.v930044d4967_1_1.CI_PIsrCorr-E-B.tiff"
#Output file locaCI Processed/2019/3G-ESP/Aug21_sentinel/#prefix#)
dfrc_output_location_prefix <- "~/Documents/R/extract_CI/hab_tracker_2017_code_share/hab_tracker/CI Processed/2018/3G-ESP/Aug24_sentinel/Aug24_sentinel"
#Distance limit for CI measurements
nD = 1000
nDD = 5000
#####################
###define features end###
#####################
#script can be divided into two parts:
#
#part 1:
#Mark Rowe 7-2-2015
#this R script will read a geotiff CI file from Stumpf/Wynne
#and write a CI and chlorophyll *.txt file
#originally, this script wass meant to be called by habtracker.R
#
#part 2:
#take the output from part 1 and compare coordinates from samples of interest
#the output will provide distance between points of ci/chlorophyll readings and sample
#####################
########Part1########
#####################
#load common data and functions: habtracker_functions.R
source("habtracker_functions.R")
#make standard format date strings from the Wynne Stumpf file names
#
string1 <- strsplit(tiff_ci_location, "/")[[1]]
string1 <- string1[length(string1)]
string2 <- strsplit(string1, "\\.")[[1]]
hr1 <- substr(string2[4],1,4)
if(is.na(as.numeric(hr1))){ # if hour is not provided in the filename
hr1 <- "1700"
}
datestring <- paste0(string2[2],hr1,"00")
year <- substr(string2[2], 1, 4)
imageDate <- as.POSIXct(datestring, format="%Y%j%H%M", tz="UTC")
datestring1 <- substr(datestring, 1, 7)
fntxt <- paste0("tiff_ci_location", format(imageDate, "M%Y%j%H%M00.txt") )
# open the geotiff
r1 <- raster(tiff_ci_location)
prj1 <- CRS(r1@crs@projargs)
if(substr(prj1@projargs, 1, 12) == " +proj=sinu "){
# I adjusted +x and +y to get it to align with shorelineLL, it was shifted north by 18.5 km or so
#  prj1 <- CRS("+proj=sinu +lon_0=-82 +x_0=1000 +y_0=18500 +ellps=WGS84 +units=m +no_defs")
}
# crop it to Lake Erie erie extent
nodes <- data.frame(
lon=c(-83.50791, -78.83501),
lat=c(41.35162, 42.93132)
)
nodes <- projxy(nodes, prj1)
xlim <- nodes$X
ylim <- nodes$Y
#  plot(r1, xlim=xlim, ylim=ylim)
e <- extent(min(xlim), max(xlim), min(ylim), max(ylim))
rc <- crop(r1, e)
#plot(rc)
dfrc <- as.data.frame(rc, xy=TRUE)
names(dfrc) <- c("X","Y","ci")
dfrc <- projLatLon(dfrc/1000, prj1)
dfrc$ci <- dfrc$ci*1000
dfrc <- dfrc[, -c(1:2)] #delete columns 1 through 2 (X and Y)
dfrc <- dfrc[dfrc$ci <= 250,] # remove land and cloud pixels
dfrc$chl <- 0
dfrc$chl[dfrc$ci == 0] <- 0
xx <- which(dfrc$ci %in% 1:250)
CI <- 10^( dfrc$ci[xx]/100 -4)
dfrc$chl[xx] <- 12570*CI + 10
#export extracted CI/chlorophyll data
write.csv(dfrc, file = paste0(dfrc_output_location_prefix, "_dfci_chl.csv"))
#####################
########Part2########
#####################
setDT(dfrc)
dfci_results <- lapply(samples, # loop through list
function(x) {
distHaversine(matrix(c(dfrc$lon, dfrc$lat), ncol = 2),
matrix(c(
subset(metadata$auv_longitude_deg, metadata$sample_name_water == x),
subset(metadata$auv_latitude_deg, metadata$sample_name_water == x)),
ncol = 2))})
dfci_results_df <- setNames(data.frame(dfci_results), samples)
dfci_final <- cbind(dfrc, dfci_results_df)
#View(dfci_final)
#export explained:
#ci is cyanobacterial index
#lon is longitude of measurement point of MODIS image
#lat is latitude of measurement point of MODIS image
#chl is calculated chlorophyll
#export sample proximity analysis to extracted CI/chlorophyll point data
write.csv(dfci_final, file = paste0(dfrc_output_location_prefix, "_dfci_final.csv"))
#View(dfci_final)
#run a few quick analysis for instant results
#order each sample by closest ci measurement (data.frame for each sample)
dfci_final_order <- lapply(samples, # loop through list
function(x) {
dfci_final[order(dfci_final[[x]]), ]})
dfci_final_order
names(dfci_final_order) <- samples
#names(dfci_final_rm) <- samples
#how many samples were run?
n = ncol(dfci_final)-4
n
#make a list of 1 through n, or how many samples were run
z <- as.list(c(1:n))
#DISTANCE nD
#remove any values further than nD
dfci_final_rm <- lapply(samples, # loop through list
function(x) {
dfci_final[!dfci_final[[x]]>nD,]})
#find the mean value for ci, or column 1 for each sample, within distance nD
dfci_final_rm_ci_mean <- lapply(z, function(x) {
colMeans(dfci_final_rm[[x]][,1])
})
#DISTANCE 2 nDD
#remove any values further than nDD
dfci_final_rm_nDD <- lapply(samples, # loop through list
function(x) {
dfci_final[!dfci_final[[x]]>nDD,]})
#find the mean value for ci, or column 1 for each sample, within distance nDD
dfci_final_rm_ci_mean_nDD <- lapply(z, function(x) {
colMeans(dfci_final_rm_nDD[[x]][,1])
})
#yay! name the mean results, rename list
samples_nD <- paste("nD", samples, sep = "_")
names(dfci_final_rm_ci_mean) <- samples_nD
samples_nDD <- paste("nDD", samples, sep = "_")
names(dfci_final_rm_ci_mean_nDD) <- samples_nDD
modis_dist_avgs <- cbind(dfci_final_rm_ci_mean, dfci_final_rm_ci_mean_nDD)
write.csv(modis_dist_avgs, file = paste0(dfrc_output_location_prefix, "_modis_dist_avgs_final.csv"))
#this is what we will stick with, just the first assigned value
singlets <- lapply(dfci_final_order, head, 1)
singlets
#extact just ci value
modis_exact_ci <- sapply(singlets, `[[`, 1)
modis_exact_lon <- sapply(singlets, `[[`, 2)
modis_exact_lat <- sapply(singlets, `[[`, 3)
modis_exact <- t(rbind(modis_exact_ci, modis_exact_lon, modis_exact_lat))
#remove any ci measurements if distance is greater than 250m
write.csv(modis_exact, file = paste0(dfrc_output_location_prefix, "_modis_exact_ci_final.csv"))
dfrc_output_location_prefix
#5 and 250 up as well as sample names should become variable!
dfci_final
singlets
View(singlets)
View(data.table(singlets))
View((data.table(singlets))[[1]][[1]])
#Assign cartridges/samples of interest
samples <- list("SC51", "SC53", "SC50", "SC48")
#Set metadata file location
metadata <- data.frame(read_excel("/Users/pdenuyl/Documents/3GESP/metadata/3GESP/For-MODIS/MODIS_only_erie_metadata_2018_v8_PD.xlsx"))
#Set working directory; for hab_tracker code
setwd("~/Documents/R/extract_CI/hab_tracker_2017_code_share/hab_tracker/")
#Location of CI processed image (one image/date only)
tiff_ci_location <- "CI Processed/2018/3G-ESP/Aug24_sentinel/Aug24.sentinel-3a.2018236.0824.1546C.L3.LE3.v930044d4967_1_1.CI_PIsrCorr-E-B.tiff"
#Output file locaCI Processed/2019/3G-ESP/Aug21_sentinel/#prefix#)
dfrc_output_location_prefix <- "~/Documents/R/extract_CI/hab_tracker_2017_code_share/hab_tracker/CI Processed/2018/3G-ESP/Aug24_sentinel/Aug24_sentinel"
#Distance limit for CI measurements
nD = 1000
nDD = 5000
#####################
########Part1########
#####################
#load common data and functions: habtracker_functions.R
source("habtracker_functions.R")
#make standard format date strings from the Wynne Stumpf file names
#
string1 <- strsplit(tiff_ci_location, "/")[[1]]
string1 <- string1[length(string1)]
string2 <- strsplit(string1, "\\.")[[1]]
hr1 <- substr(string2[4],1,4)
if(is.na(as.numeric(hr1))){ # if hour is not provided in the filename
hr1 <- "1700"
}
datestring <- paste0(string2[2],hr1,"00")
year <- substr(string2[2], 1, 4)
imageDate <- as.POSIXct(datestring, format="%Y%j%H%M", tz="UTC")
datestring1 <- substr(datestring, 1, 7)
fntxt <- paste0("tiff_ci_location", format(imageDate, "M%Y%j%H%M00.txt") )
# open the geotiff
r1 <- raster(tiff_ci_location)
prj1 <- CRS(r1@crs@projargs)
if(substr(prj1@projargs, 1, 12) == " +proj=sinu "){
# I adjusted +x and +y to get it to align with shorelineLL, it was shifted north by 18.5 km or so
#  prj1 <- CRS("+proj=sinu +lon_0=-82 +x_0=1000 +y_0=18500 +ellps=WGS84 +units=m +no_defs")
}
# crop it to Lake Erie erie extent
nodes <- data.frame(
lon=c(-83.50791, -78.83501),
lat=c(41.35162, 42.93132)
)
nodes <- projxy(nodes, prj1)
xlim <- nodes$X
ylim <- nodes$Y
e <- extent(min(xlim), max(xlim), min(ylim), max(ylim))
rc <- crop(r1, e)
dfrc <- as.data.frame(rc, xy=TRUE)
names(dfrc) <- c("X","Y","ci")
dfrc <- projLatLon(dfrc/1000, prj1)
dfrc$ci <- dfrc$ci*1000
dfrc <- dfrc[, -c(1:2)] #delete columns 1 through 2 (X and Y)
dfrc <- dfrc[dfrc$ci <= 250,] # remove land and cloud pixels
dfrc$chl <- 0
dfrc$chl[dfrc$ci == 0] <- 0
xx <- which(dfrc$ci %in% 1:250)
CI <- 10^( dfrc$ci[xx]/100 -4)
dfrc$chl[xx] <- 12570*CI + 10
#export extracted CI/chlorophyll data
write.csv(dfrc, file = paste0(dfrc_output_location_prefix, "_dfci_chl.csv"))
#####################
########Part2########
#####################
setDT(dfrc)
dfci_results <- lapply(samples, # loop through list
function(x) {
distHaversine(matrix(c(dfrc$lon, dfrc$lat), ncol = 2),
matrix(c(
subset(metadata$auv_longitude_deg, metadata$sample_name_water == x),
subset(metadata$auv_latitude_deg, metadata$sample_name_water == x)),
ncol = 2))})
dfci_results_df <- setNames(data.frame(dfci_results), samples)
dfci_final <- cbind(dfrc, dfci_results_df)
#export sample proximity analysis to extracted CI/chlorophyll point data
write.csv(dfci_final, file = paste0(dfrc_output_location_prefix, "_dfci_final.csv"))
#order each sample by closest ci measurement (data.frame for each sample)
dfci_final_order <- lapply(samples, # loop through list
function(x) {
dfci_final[order(dfci_final[[x]]), ]})
dfci_final_order
names(dfci_final_order) <- samples
#how many samples were run?
n = ncol(dfci_final)-4
n
#make a list of 1 through n, or how many samples were run
z <- as.list(c(1:n))
#DISTANCE nD
#remove any values further than nD
dfci_final_rm <- lapply(samples, # loop through list
function(x) {
dfci_final[!dfci_final[[x]]>nD,]})
#find the mean value for ci, or column 1 for each sample, within distance nD
dfci_final_rm_ci_mean <- lapply(z, function(x) {
colMeans(dfci_final_rm[[x]][,1])
})
#DISTANCE 2 nDD
#remove any values further than nDD
dfci_final_rm_nDD <- lapply(samples, # loop through list
function(x) {
dfci_final[!dfci_final[[x]]>nDD,]})
#find the mean value for ci, or column 1 for each sample, within distance nDD
dfci_final_rm_ci_mean_nDD <- lapply(z, function(x) {
colMeans(dfci_final_rm_nDD[[x]][,1])
})
#yay! name the mean results, rename list
samples_nD <- paste("nD", samples, sep = "_")
names(dfci_final_rm_ci_mean) <- samples_nD
samples_nDD <- paste("nDD", samples, sep = "_")
names(dfci_final_rm_ci_mean_nDD) <- samples_nDD
modis_dist_avgs <- cbind(dfci_final_rm_ci_mean, dfci_final_rm_ci_mean_nDD)
write.csv(modis_dist_avgs, file = paste0(dfrc_output_location_prefix, "_modis_dist_avgs_final.csv"))
#this is what we will stick with, just the first assigned value
singlets <- lapply(dfci_final_order, head, 1)
singlets
#extact just ci value
modis_exact_ci <- sapply(singlets, `[[`, 1)
modis_exact_lon <- sapply(singlets, `[[`, 2)
modis_exact_lat <- sapply(singlets, `[[`, 3)
modis_exact <- t(rbind(modis_exact_ci, modis_exact_lon, modis_exact_lat))
#remove any ci measurements if distance is greater than 250m
write.csv(modis_exact, file = paste0(dfrc_output_location_prefix, "_modis_exact_ci_final.csv"))
dfrc_output_location_prefix
#5 and 250 up as well as sample names should become variable!
#5 and 250 up as well as sample names should become variable!
#5 and 250 up as well as sample names should become variable!
#5 and 250 up as well as sample names should become variable!
#5 and 250 up as well as sample names should become variable!
singlets
